const fs = require('fs');
const path = require('path');

// Base directory â€” adjust for local vs Vercel
const CLAWD_DIR = process.env.CLAWD_DIR || '/Users/stanley/clawd';
const SESSIONS_DIR = process.env.SESSIONS_DIR || path.join(require('os').homedir(), '.clawdbot/agents/main/sessions');

// Bundled data fallback for Vercel (generated by scripts/build-docs.js)
let bundledIndex = null;
let bundledContents = null;
try {
  bundledIndex = require('./docs-index.json');
  bundledContents = require('./docs-contents.json');
} catch (e) { /* not bundled, use filesystem */ }

const TAG_MAP = {
  'memory/daily': { tag: 'Journal', color: '#3fb950' },
  'memory/people': { tag: 'People', color: '#58a6ff' },
  'memory/projects': { tag: 'Projects', color: '#a371f7' },
  'memory/learnings': { tag: 'Learnings', color: '#f0883e' },
  'memory/conversations': { tag: 'Conversations', color: '#39d5e6' },
  'memory/preferences': { tag: 'Preferences', color: '#d2a8ff' },
  'memory/backups': { tag: 'Backups', color: '#8b949e' },
  'agents/kaizen': { tag: 'Kaizen', color: '#d29922' },
  'sessions': { tag: 'Sessions', color: '#f778ba' },
};

function getTag(relPath) {
  for (const [prefix, info] of Object.entries(TAG_MAP)) {
    if (relPath.startsWith(prefix + '/') || relPath.startsWith(prefix + '\\')) return info;
  }
  // Root .md files
  if (!relPath.includes('/') && !relPath.includes('\\')) return { tag: 'Core', color: '#f85149' };
  // Memory root files (not in a subdir of memory)
  if (relPath.startsWith('memory/') && relPath.split('/').length === 2) return { tag: 'Memory', color: '#d2a8ff' };
  return { tag: 'Other', color: '#8b949e' };
}

function timeAgo(date) {
  const now = Date.now();
  const diff = now - new Date(date).getTime();
  const mins = Math.floor(diff / 60000);
  if (mins < 60) return `${mins}m ago`;
  const hours = Math.floor(mins / 60);
  if (hours < 24) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  if (days < 30) return `${days}d ago`;
  const months = Math.floor(days / 30);
  return `${months}mo ago`;
}

function scanDir(dir, relBase) {
  const results = [];
  if (!fs.existsSync(dir)) return results;
  
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relPath = path.join(relBase, entry.name);
    
    if (entry.isDirectory()) {
      // Skip node_modules, .git, backups
      if (['node_modules', '.git', 'backups'].includes(entry.name)) continue;
      results.push(...scanDir(fullPath, relPath));
    } else if (entry.name.endsWith('.md')) {
      try {
        const stat = fs.statSync(fullPath);
        const content = fs.readFileSync(fullPath, 'utf-8');
        const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;
        const tagInfo = getTag(relPath);
        
        results.push({
          name: entry.name,
          path: relPath,
          size: stat.size,
          sizeHuman: stat.size < 1024 ? `${stat.size}B` : stat.size < 1048576 ? `${(stat.size/1024).toFixed(1)}KB` : `${(stat.size/1048576).toFixed(1)}MB`,
          modified: stat.mtime.toISOString(),
          age: timeAgo(stat.mtime),
          words: wordCount,
          tag: tagInfo.tag,
          tagColor: tagInfo.color,
          type: '.md',
        });
      } catch (e) { /* skip unreadable */ }
    }
  }
  return results;
}

function scanSessions() {
  const results = [];
  if (!fs.existsSync(SESSIONS_DIR)) return results;
  
  const files = fs.readdirSync(SESSIONS_DIR).filter(f => f.endsWith('.jsonl'));
  for (const file of files) {
    try {
      const fullPath = path.join(SESSIONS_DIR, file);
      const stat = fs.statSync(fullPath);
      const tagInfo = { tag: 'Sessions', color: '#f778ba' };
      
      // Read first line for session metadata
      const firstLine = fs.readFileSync(fullPath, 'utf-8').split('\n')[0];
      let preview = file.replace('.jsonl', '');
      try {
        const meta = JSON.parse(firstLine);
        if (meta.channel) preview = `${meta.channel} session`;
      } catch (e) {}
      
      results.push({
        name: file,
        path: `sessions/${file}`,
        size: stat.size,
        sizeHuman: stat.size < 1024 ? `${stat.size}B` : stat.size < 1048576 ? `${(stat.size/1024).toFixed(1)}KB` : `${(stat.size/1048576).toFixed(1)}MB`,
        modified: stat.mtime.toISOString(),
        age: timeAgo(stat.mtime),
        words: 0,
        tag: tagInfo.tag,
        tagColor: tagInfo.color,
        type: '.jsonl',
        preview,
      });
    } catch (e) {}
  }
  return results;
}

function getFileContent(relPath) {
  // Security: prevent path traversal
  const normalized = path.normalize(relPath).replace(/^(\.\.[\/\\])+/, '');
  if (normalized.includes('..')) return null;
  
  if (normalized.startsWith('sessions/')) {
    const sessionFile = path.join(SESSIONS_DIR, normalized.replace('sessions/', ''));
    if (!fs.existsSync(sessionFile)) return null;
    
    // Parse JSONL â€” extract key messages only (these files are huge)
    const lines = fs.readFileSync(sessionFile, 'utf-8').split('\n').filter(l => l.trim());
    const messages = [];
    let msgCount = 0;
    
    for (const line of lines) {
      try {
        const obj = JSON.parse(line);
        msgCount++;
        if (obj.role === 'user' || obj.role === 'assistant') {
          const content = typeof obj.content === 'string' ? obj.content : 
                         Array.isArray(obj.content) ? obj.content.map(c => c.text || '').join('') : '';
          if (content.length > 0) {
            messages.push({
              role: obj.role,
              preview: content.substring(0, 500) + (content.length > 500 ? '...' : ''),
              timestamp: obj.timestamp || null,
            });
          }
        }
      } catch (e) {}
    }
    
    // Format as readable markdown
    let md = `# Session: ${path.basename(relPath, '.jsonl')}\n\n`;
    md += `**Total entries:** ${msgCount} | **Messages shown:** ${messages.length}\n\n---\n\n`;
    
    for (const msg of messages.slice(0, 100)) {
      const icon = msg.role === 'user' ? 'ðŸ‘¤' : 'ðŸ¤–';
      md += `### ${icon} ${msg.role}\n\n${msg.preview}\n\n---\n\n`;
    }
    
    if (messages.length > 100) {
      md += `\n*... ${messages.length - 100} more messages truncated*\n`;
    }
    
    return md;
  }
  
  // Regular file
  const fullPath = path.join(CLAWD_DIR, normalized);
  if (!fs.existsSync(fullPath)) return null;
  return fs.readFileSync(fullPath, 'utf-8');
}

module.exports = async function handler(req, res) {
  if (req.method === 'OPTIONS') return res.status(200).end();
  if (req.method !== 'GET') return res.status(405).json({ error: 'Method not allowed' });
  
  const { file } = req.query;
  
  // Single file content
  if (file) {
    // Try bundled first
    if (bundledContents && bundledContents[file]) {
      return res.status(200).json({ content: bundledContents[file] });
    }
    
    const content = getFileContent(file);
    if (content === null) return res.status(404).json({ error: 'File not found' });
    return res.status(200).json({ content });
  }
  
  // File listing
  if (bundledIndex) {
    return res.status(200).json({ files: bundledIndex });
  }
  
  const files = [];
  
  // Root .md files
  const rootMds = ['AGENTS.md', 'MEMORY.md', 'SOUL.md', 'USER.md', 'TOOLS.md', 'IDENTITY.md', 'HEARTBEAT.md',
                   'AI_KNOWLEDGE_BASE.md', 'GETTING_TO_KNOW_YOU.md', 'LEARNING_PLAN.md', 'RESEARCH_UPDATE_2026-01-26.md'];
  for (const name of rootMds) {
    const fullPath = path.join(CLAWD_DIR, name);
    if (fs.existsSync(fullPath)) {
      try {
        const stat = fs.statSync(fullPath);
        const content = fs.readFileSync(fullPath, 'utf-8');
        const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;
        files.push({
          name, path: name, size: stat.size,
          sizeHuman: stat.size < 1024 ? `${stat.size}B` : `${(stat.size/1024).toFixed(1)}KB`,
          modified: stat.mtime.toISOString(), age: timeAgo(stat.mtime),
          words: wordCount, tag: 'Core', tagColor: '#f85149', type: '.md',
        });
      } catch (e) {}
    }
  }
  
  // Memory subdirectories
  files.push(...scanDir(path.join(CLAWD_DIR, 'memory'), 'memory'));
  
  // Kaizen
  files.push(...scanDir(path.join(CLAWD_DIR, 'agents/kaizen'), 'agents/kaizen'));
  
  // Sessions
  files.push(...scanSessions());
  
  // Sort by modified desc
  files.sort((a, b) => new Date(b.modified) - new Date(a.modified));
  
  return res.status(200).json({ files, total: files.length });
};
